//! SQLite parser
use log::error;

pub mod ast;
pub mod parse {
    #![allow(unused_braces)]
    #![allow(unused_comparisons)] // FIXME
    #![allow(clippy::collapsible_if)]
    #![allow(clippy::if_same_then_else)]
    #![allow(clippy::absurd_extreme_comparisons)] // FIXME
    #![allow(clippy::needless_return)]
    #![allow(clippy::upper_case_acronyms)]

    include!(concat!(env!("OUT_DIR"), "/parse.rs"));
}

use ast::{Cmd, ExplainKind, Name, Stmt};

use self::ast::ModuleArgument;

/// Parser error
#[derive(Debug)]
pub enum ParserError {
    StackOverflow,
    SyntaxError {
        token_type: &'static str,
        found: Option<String>,
    },
    UnexpectedEof,
    Custom(String),
}

impl std::fmt::Display for ParserError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            ParserError::StackOverflow => f.write_str("parser overflowed its stack"),
            ParserError::SyntaxError { token_type, found } => {
                write!(f, "near {}, \"{:?}\": syntax error", token_type, found)
            }
            ParserError::UnexpectedEof => f.write_str("unexpected end of input"),
            ParserError::Custom(s) => f.write_str(s),
        }
    }
}

impl std::error::Error for ParserError {}

/// Parser context
pub struct Context {
    explain: Option<ExplainKind>,
    stmt: Option<Stmt>,
    constraint_name: Option<Name>, // transient
    done: bool,
    error: Option<ParserError>,
    module_arguments: Option<Vec<ModuleArgument>>,
}

impl Context {
    pub fn new() -> Context {
        Context {
            explain: None,
            stmt: None,
            constraint_name: None,
            done: false,
            error: None,
            module_arguments: None,
        }
    }

    /// Consume parsed command
    pub fn cmd(&mut self) -> Option<Cmd> {
        if let Some(stmt) = self.stmt.take() {
            match self.explain.take() {
                Some(ExplainKind::Explain) => Some(Cmd::Explain(stmt)),
                Some(ExplainKind::QueryPlan) => Some(Cmd::ExplainQueryPlan(stmt)),
                None => Some(Cmd::Stmt(stmt)),
            }
        } else {
            None
        }
    }

    fn constraint_name(&mut self) -> Option<Name> {
        self.constraint_name.take()
    }
    fn no_constraint_name(&self) -> bool {
        self.constraint_name.is_none()
    }

    fn sqlite3_error_msg(&mut self, msg: &str) {
        error!("parser error: {}", msg);
    }

    /// This routine is called after a single SQL statement has been parsed.
    fn sqlite3_finish_coding(&mut self) {
        self.done = true;
    }

    /// Return `true` if parser completes either successfully or with an error.
    pub fn done(&self) -> bool {
        self.done || self.error.is_some()
    }

    pub fn is_ok(&self) -> bool {
        self.error.is_none()
    }

    /// Consume error generated by parser
    pub fn error(&mut self) -> Option<ParserError> {
        self.error.take()
    }

    pub fn reset(&mut self) {
        self.explain = None;
        self.stmt = None;
        self.constraint_name = None;
        self.done = false;
        self.error = None;
        self.module_arguments = None;
    }

    /// initializes argument an argument for the virtual table module currently being parsed.
    pub fn init_vtab_arg(&mut self) {
        match self.module_arguments {
            Some(ref mut args) => args.push(ModuleArgument::default()),
            None => self.module_arguments = Some(vec![ModuleArgument::default()]),
        }
    }

    /// add a token to the virtual table module argument currently being parsed.
    pub fn add_to_vtab_argument(&mut self, s: String) -> Result<(), ParserError> {
        match self.module_arguments {
            Some(ref mut args) => {
                let last = args.last_mut().ok_or_else(|| {
                    ParserError::Custom("uninitialized module arguments".to_string())
                })?;
                last.push(s);
                Ok(())
            }
            None => Err(ParserError::Custom(
                "uninitialized module arguments".to_string(),
            )),
        }
    }
}
